// Copyright 2019 deltam

// Package perm provides a permutation generator based on group theory.
//
// This algorithm is based on below paper.
//
// [[1307.2549] Hamiltonicity of the Cayley Digraph on the Symmetric Group Generated by σ = (1 2 ... n) and τ = (1 2)](https://arxiv.org/abs/1307.2549)
package perm

import "reflect"

type Generator interface {
	Index() []int
	HasNext() bool
	Next() (swapped bool)
}

// permState represents current permutation
type permState struct {
	cur            []int
	done           bool
	smallCycleRest int
	successor      func(*permState) bool
}

// New returns permutation generator
func New(n int) (Generator, error) {
	start := make([]int, n)
	if err := Init(start); err != nil {
		return nil, err
	}
	return &permState{
		cur:            start,
		smallCycleRest: 2 * (n - 1),
		successor:      successorSmallCycle,
	}, nil
}

// StartFrom returns permutation generator that start from specified permutation
func StartFrom(index []int) Generator {
	cur := make([]int, len(index))
	copy(cur, index)
	largeCycle := true
	// Does index belong to Large Cycle?
	if n := len(index); n > 2 && (index[0] == n-1 || index[1] == n-1) {
		for i := 2; i < n+2; i++ {
			j := (i + 1) % n
			if index[j] == n-1 {
				j++
			}
			if index[i%n]-1 != index[j] {
				largeCycle = false
				break
			}
		}
	}
	if largeCycle {
		return &permState{
			cur:       cur,
			successor: successorLargeCycle,
		}
	}
	return &permState{
		cur:       cur,
		successor: successorSmallCycle2,
	}
}

// Index returns current permutation as array
//
// CAUTION: If edit returned array, generator breaks
func (p *permState) Index() []int {
	return p.cur
}

// HasNext returns true if current permutation is not last
func (p *permState) HasNext() bool {
	return !p.done
}

// Next changes current permutation to next
func (p *permState) Next() bool {
	if p.done {
		return false
	}
	return p.successor(p)
}

// if returns true do swap
func successorSmallCycle(p *permState) bool {
	p.smallCycleRest--
	if p.smallCycleRest <= 0 {
		p.successor = successorLargeCycle
		OpShift(p.cur)
		return false
	}
	if p.smallCycleRest%2 == 0 {
		OpSwap(p.cur)
		return true
	}
	OpShift(p.cur)
	return false
}

func successorSmallCycle2(p *permState) bool {
	if IsSwap(p.cur) {
		if IsSmallCycleEnd(p.cur) {
			p.successor = successorLargeCycle
			OpShift(p.cur)
			return false
		}
		OpSwap(p.cur)
		return true
	}
	OpShift(p.cur)
	return false
}

func successorLargeCycle(p *permState) bool {
	if IsSwap(p.cur) {
		if IsEnd(p.cur) {
			p.done = true
			return false
		}
		OpSwap(p.cur)
		return true
	}
	OpShift(p.cur)
	return false
}

type iterator struct {
	g     Generator
	slice interface{}
}

func Bind(g Generator, slice interface{}) Generator {
	return &iterator{g: g, slice: slice}
}

// Iter returns an iterator of slice's all permutation
func Iter(slice interface{}) (Generator, error) {
	rv := reflect.ValueOf(slice)
	len := rv.Len()
	g, err := New(len)
	if err != nil {
		return nil, err
	}
	return Bind(g, slice), nil
}

func (it *iterator) Index() []int {
	return it.g.Index()
}

func (it *iterator) HasNext() bool {
	return it.g.HasNext()
}

func (it *iterator) Next() (swapped bool) {
	if !it.g.HasNext() {
		return false
	}

	swapped = it.g.Next()
	if swapped {
		swapSlice(it.slice)
		return
	}
	shiftSlice(it.slice)
	return
}

func shiftSlice(slice interface{}) {
	rv := reflect.ValueOf(slice)
	n := rv.Len()
	f := rv.Index(0).Interface()
	reflect.Copy(rv.Slice(0, n-1), rv.Slice(1, n))
	rv.Index(n - 1).Set(reflect.ValueOf(f))
}

func swapSlice(slice interface{}) {
	reflect.Swapper(slice)(0, 1)
}
